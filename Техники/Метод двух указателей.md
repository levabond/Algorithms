## Метод двух указателей

Алгоритм двух указателей — это метод используется для перемещения по массиву или списку, в котором вы используете два указателя. Они движутся навстречу друг другу. Подход эффективен при решении задач, где необходимо найти пары, определить сумму элементов или найти определенное целевое значение в отсортированном массиве.

* сложность по памяти — O(1)
* сложность по времени — O(n)

# **Когда мы его используем?**

1. Поиск пары элементов, сумма которых равна целевому значению в отсортированном массиве.
2. Удаление дубликатов из отсортированного массива.
3. Определение длины самого длинного подмассива с определенной суммой.
4. Нахождение наименьшего подмассива с определенной суммой.
5. Нахождение ближайшей пары точек на 2D-плоскости.
6. Определение максимальной суммы подмассива в заданном массиве.
7. Поиск первого неповторяющегося символа в строке.

# **Как мы его используем? Каков подход?**

Вот общий подход к реализации алгоритма с двумя указателями:

1. Инициализируйте два указателя, обычно в начале и конце массива или списка.
2. Проверьте, соответствуют ли текущие элементы по двум указателям некоторому условию.
3. Если условие выполнено, верните результат.
4. Если условие не выполняется, переместите один из указателей на основе некоторой логики, чтобы уменьшить размер проблемного пространства.
5. Повторяйте шаги со 2 по 4, пока указатели не встретятся или условие не будет выполнено.
6. Если условие не выполнено, верните соответствующий результат.

Разбор задач

[Leetcode: 1. Two sum](https://leetcode.com/problems/two-sum/)

*Дан массив целых чисел, необходимо вернуть индексы двух чисел, сумма которых равна заданному числу. Можно считать, что массив будет иметь ровно одно решение. Нельзя использовать одно и то же число дважды.*

*`Аргументы: [2, 7, 11, 15], 9 Ответ: [0, 1] Объяснение: nums[0] + nums[1] = 2 + 7 = 9`*

Для случая, когда массив чисел **упорядочен**, идеально подойдёт подход с двумя указателями. Сначала левый указатель указывает на начало массива, а правый на его конец. Если их сумма равна целевому значению, то мы выходим, если нет, то:

* если сумма больше целевого значения, то нам нужна меньшая сумма (логично, да?) и мы сдвигаем левее правый указатель
* если сумма меньше целевого значения, то мы сдвигаем левый указатель, чтобы её увеличить

Решение

```swift
// найти пару элементов, 
// сумма которых равна целевому значению в отсортированном массиве:

func twoSum(numbers: [Int], target: Int) -> [Int] {
    var left = 0
    var right = numbers.count - 1
    while left < right {
        let sum = numbers[left] + numbers[right]
        if sum == target {
            return [left, right]
        } else if sum < target {
            left += 1
        } else {
            right -= 1
        }
    }
    return []
}

```

Если же входящий массив не отсортирован и мы хотим сохранить линейную сложность

```swift
func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    var dict = [Int: Int]()

    for (index, item) in nums.enumerated() {
        if let prevIndex = dict[target - item] {
            return [index, prevIndex]
        }
        dict[item] = index
    }
    return []
}

```

Первым делом, переносим массив в словарь, в качестве ключей — числа, а значений — их индексы. Во время второго прохода проверяем, есть ли число равное *target*−*x* (элементарная математика, нам нужно же найти *x*+*y*=*target*, которое можно переформулировать в первое выражение). Если есть — отлично, если нет — идём дальше. Таким образом, имеем временную сложность *O*(*n*) и сложность по памяти *O*(*n*).

---

## Удаление дубликатов из отсортированного массива

[Удаление дубликатов из отсортированного массива](https://www.notion.so/b4161a7e0a6d40d1bdc0526c02f0aa09?pvs=21)

---

## Поиск палиндрома

[Поиск палиндрома](https://www.notion.so/6ea1f7aabf13423389097f413578d25b?pvs=21)

Статьи:

[Метод двух указателей](https://wcademy.ru/two-pointers-method/)

[Two Pointer Technique in Swift](https://medium.com/@mhcsunny/two-pointer-technique-in-swift-8f4bad8cbcbe)

[https://leetcode.com/problems/remove-duplicates-from-sorted-array/](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

[https://leetcode.com/problems/remove-element/description/](https://leetcode.com/problems/remove-element/description/)

[https://leetcode.com/problems/valid-palindrome/description/](https://leetcode.com/problems/valid-palindrome/description/)

[https://leetcode.com/problems/intersection-of-two-arrays/description/](https://leetcode.com/problems/intersection-of-two-arrays/description/)

[https://leetcode.com/problems/intersection-of-two-arrays-ii/description/](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/)
